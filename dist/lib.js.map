{"version":3,"file":"lib.js","sources":["../src/index.ts"],"sourcesContent":["import { VNodeData } from \"vue\"\n\nconst keys = Object.keys\n\nfunction concat(...items: any[]): any[]\nfunction concat(...items: any[][]): any[]\nfunction concat() {\n    return Array.prototype.concat.apply([], arguments)\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nfunction mergeData(...vNodeData: VNodeData[]): VNodeData\nfunction mergeData() {\n    // Start by copying the first arg into a fresh object\n    let mergeTarget = { ...arguments[0] }\n\n    // Allow for variadic argument length.\n    // Skip first argument that was assigned to mergeTarget.\n    for (let i = 1; i < arguments.length; i++) {\n        // Iterate through the data properties and execute merge strategies\n        // Object.keys eliminates need for hasOwnProperty call\n        for (const prop of keys(arguments[i])) {\n            // If strictly undefined, simply assign value and continue\n            if (mergeTarget[prop] === undefined) {\n                mergeTarget[prop] = arguments[i][prop]\n                continue\n            }\n\n            switch (prop) {\n                // Array merge strategy (array concatenation)\n                case \"class\":\n                case \"style\":\n                case \"directives\":\n                    // Repackaging in an array allows Vue runtime\n                    // to merge class/style bindings regardless of type.\n                    mergeTarget[prop] = concat(mergeTarget[prop], arguments[i][prop])\n                    break\n\n                // Space delimited string concatenation strategy\n                case \"staticClass\":\n                    // If we get here,\n                    // value !== undefined,\n                    // but it could still be an empty string.\n                    if (mergeTarget[prop]) {\n                        // Not an empty string, so concatenate\n                        mergeTarget[prop] = mergeTarget[prop].trim() + \" \"\n                    }\n                    mergeTarget[prop] += arguments[i][prop].trim()\n                    break\n\n                // Object, the properties of which to merge via array merge strategy (array concatenation).\n                // Callback merge strategy merges callbacks to the beginning of the array,\n                // so that the last defined callback will be invoked first.\n                // This is done since to mimic how Object.assign merging\n                // uses the last given value to assign.\n                case \"on\":\n                case \"nativeOn\":\n                    // If we get here,\n                    // value must be of type Object.\n                    for (const event of keys(arguments[i][prop])) {\n                        // Insert current iteration data in beginning of merged array.\n                        mergeTarget[prop][event] = concat(arguments[i][prop][event], mergeTarget[prop][event])\n                    }\n                    break\n\n                // Object merge strategy\n                case \"attrs\":\n                case \"props\":\n                case \"domProps\":\n                case \"scopedSlots\":\n                case \"staticStyle\":\n                case \"hook\":\n                case \"transition\":\n                    mergeTarget[prop] = { ...mergeTarget[prop], ...arguments[i][prop] }\n                    break\n\n                // Reassignment strategy (no merge)\n                case \"slot\":\n                case \"key\":\n                case \"ref\":\n                case \"tag\":\n                case \"show\":\n                case \"keepAlive\":\n                default:\n                    mergeTarget[prop] = arguments[i][prop]\n            }\n        }\n    }\n\n    return mergeTarget\n}\n\nexport default mergeData\n"],"names":["Array","prototype","concat","apply","arguments","keys","Object","mergeTarget","i","length","_a","_i","prop","undefined","trim","_c","_b","event_1"],"mappings":"sCAMA,aACI,OAAOA,MAAMC,UAAUC,OAAOC,SAAUC,qLALtCC,EAAOC,OAAOD,YAcpB,WAMI,IAAK,IAJDE,OAAmBH,UAAU,IAIxBI,EAAI,EAAGA,EAAIJ,UAAUK,OAAQD,IAGlC,IAAmB,QAAAE,EAAAL,EAAKD,UAAUI,IAAfG,WAAAA,KAAd,IAAMC,OAEP,QAA0BC,IAAtBN,EAAYK,GAKhB,OAAQA,GAEJ,IAAK,QACL,IAAK,QACL,IAAK,aAGDL,EAAYK,GAAQV,EAAOK,EAAYK,GAAOR,UAAUI,GAAGI,IAC3D,MAGJ,IAAK,cAIGL,EAAYK,KAEZL,EAAYK,GAAQL,EAAYK,GAAME,OAAS,KAEnDP,EAAYK,IAASR,UAAUI,GAAGI,GAAME,OACxC,MAOJ,IAAK,KACL,IAAK,WAGD,IAAoB,QAAAC,EAAAV,EAAKD,UAAUI,GAAGI,IAAlBI,WAAAA,KAAf,IAAMC,OAEPV,EAAYK,GAAMK,GAASf,EAAOE,UAAUI,GAAGI,GAAMK,GAAQV,EAAYK,GAAMK,IAEnF,MAGJ,IAAK,QACL,IAAK,QACL,IAAK,WACL,IAAK,cACL,IAAK,cACL,IAAK,OACL,IAAK,aACDV,EAAYK,QAAaL,EAAYK,GAAUR,UAAUI,GAAGI,IAC5D,MAGJ,IAAK,OACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,OACL,IAAK,YACL,QACIL,EAAYK,GAAQR,UAAUI,GAAGI,QA5DrCL,EAAYK,GAAQR,UAAUI,GAAGI,GAiE7C,OAAOL"}